```eval_rst
:github_url: https://github.com/littlevgl/docs/blob/master/en/overview/style.md
```
# Styles


*Styles* are used to set the appearance of the objects. Styles in lvgl are heavily inspired by CSS. The concept in nutshell is the following:
- A style is an `lv_style_t` variable which can hold properties, for example border width, text color and so on. It's similar to `class` in CSS. 
- Not all properties have to be specified. Unspecified properties will use a default value.
- Styles can be assigned to objects to change their appearance.
- A style can be used by any number of objects.
- Styles can be cascaded which means multiple styles can be assigned to an object and each style can have different properties.  
For example `style_btn` can result in a default gray button and `style_btn_red` can add only a `background-color=red` to overwrite the background color.
- Later added styles have higher precedence. It means if a property is specified in two styles the later added will be used.
- Some properties (e.g. text color) can be inherited from the parent(s) if it's not specified in the object. 
- Objects can have local styles which has higher precedence than "normal" styles.
- Unlike CSS (where pseudo classes describes different states, e.g. `:hover`), in lvgl a property is assigned to a given state.
- Transition can be applied when the object changes state.


## States
The objects can be in the following states:
- **LV_STATE_DEFAULT** (0x00): Normal, released
- **LV_STATE_CHECKED** (0x01): Toggled or checked
- **LV_STATE_FOCUSED** (0x02): Focused via keypad or encoder or clicked via touchpad/mouse 
- **LV_STATE_EDITED**  (0x04): Edit by an encoder
- **LV_STATE_HOVERED** (0x08): Hovered by mouse (not supported now)
- **LV_STATE_PRESSED** (0x10): Pressed
- **LV_STATE_DISABLED** (0x20): Disabled or inactive
	
Combination of states are	also possible, for example `LV_STATE_FOCUSED | LV_STATE_PRESSED`. 

The styles properties can be defined in every state and state combination. For example setting different background color for default and pressed state. 
If a property is not defined in a state the best matching state's property will be used. Typically it means the property with `LV_STATE_DEFAULT` state.Ë›
If the property is not set even for the default state the default value will be used. (See later)

But what does the "best matching state's property" really means? 
States has a precedence which is shown by their value (see in the above list). A higher value means a higher precedence.
To determine which state's property to use let's use an example. Let's see the background color is defined like this:
- `LV_STATE_DEFAULT`: white
- `LV_STATE_PRESSED`: gray
- `LV_STATE_FOCUSED`: red

1. By the default the object is in default state, so it's a simple case: the property is perfectly defined in object's current state as white
2. When the object is pressed there are 2 related properties: default with white (default is related to every state) and pressed with gray. 
The pressed state has 0x10 precedence which is higher than the default state's 0x00 precedence, so gray color will be used.
3. When the object is focused the same thing happens as in pressed state and red color will be used.
4. When the object is focused and pressed both gray and red would work, but the pressed state has higher precedence than focused so gray color will be used.
5. It's possible to set e.g rose color for `LV_STATE_PRESSED | LV_STATE_FOCUSED`. 
In this case this combined state has 0x2 + 0x10 = 0x12 precedence, which higher than the pressed states precedence so rose color would be used.
6. When the object is checked there is no property to set the background color for this state. So in lack of a better option the object remains white from the default state's property.
 

## Cascading styles


## Inheritance 
 

## Part of the objects
Objects can have *parts* which can have their own style. For example a [page](lv_has) has four parts:
- Background
- Scrollable
- Scrollbar
- Edge flash

![page_small.png](A scrollable page in lvgl)

There is three type of of object parts **main**, **virtual** and **real**. 

The main part is usually the background and largest part of the object. Some object has only has main part. For example a button has only a background.

The virtual parts are additional parts just drawn on the fly to the main part. There is no "real" object behind them. 
For example the page's scrollbar is not a real object, it's just drawn when the page's background is drawn. 
The virtual parts always have the same state as the main part. 
If the property can be inherited, the main part will be also considered before going to the parent.

The real parts are real objects created and managed by the main object. For example the page's scrollable part is real object. 
Real parts can be in different state than the main part.

To see which parts an object has see their documentation.

## Initialize styles and set/get properties

Styles are stored in `lv_style_t` variables. Style variables should be `static`, global or dynamically allocated. In other words they can not be local variables in functions which are destroyed when the function exists. 
Before using a style it should be initialized with `lv_style_init(&my_style)`. 
After initializing the style properties can be set added to it.
Property set functions looks like this: `lv_style_set_<property_name>(&style, <state>, <value>);`
For example the [above mentioned](#states) example looks like this:
```c
static lv_style_t style1;
lv_style_set_bg_color(&style1, LV_STATE_DEFAULT, LV_COLOR_WHITE);
lv_style_set_bg_color(&style1, LV_STATE_PRESSED, LV_COLOR_GRAY);
lv_style_set_bg_color(&style1, LV_STATE_FOCUSED, LV_COLOR_RED);
lv_style_set_bg_color(&style1, LV_STATE_FOCUSED | LV_STATE_PRESSED, lv_color_hex(0xf88));
```

It's possible to copy a style with `lv_style_copy(&style_destination, &style_source)`. After copy properties still can be added freely. 

To remove a property use:

```c
lv_style_remove_prop(&style, LV_STYLE_BG_COLOR | (LV_STATE_PRESSED << LV_STYLE_STATE_POS));
```

To get the value from style in a state functions with the following prototype are available: `lv_style_get_<prperty_name>(&style, <state>, <result poiner>);`.
The the best matching property will be selected and it's precedence will be returned. `-1` will be returned if the property is not found. For example:
```c
lv_color_t color;
int16_t res;
res = lv_style_get_bg_color(&style1, LV_STATE_PRESSED, &color);
if(res >= 0) {
	... the bg_color is loaded into `color` ... 
}
```

To reset a style (free all it's data) use 
```c
lv_style_reset(&style);
```

## Managing style list

## Local styles

## Transitions

## Properties

The following properties can be used in the styles.

### Mixed properties
- **radius** (`lv_style_int_t`): Set the radius of the background. 0: no radius, `LV_RADIUS_CIRCLE`: maximal radius. 
- **clip_corner** (`bool`): `true`: enable to clip the overflowed content on the rounded (radius > 0) corners.
- **size** (`lv_style_int_t`): Size of internal elements of the widgets. See the documentation of the widgets if this property is used or not.
- **transform_width**  (`lv_style_int_t`): Make the object wider on both sides with this value.
- **transform_height**  (`lv_style_int_t`) Make the object higher on both sides with this value.
- **opa_scale** (`lv_style_int_t`): Inherited. Scale down all opacity values of the object by this factor. As it's inherited the children objects will be affected too. 

### Padding properties
Set the space on the edges and between the children objects. Typically used by [Container](/object-types/cont) object if [layout](/object-types/cont.html#layout) or 
[auto fit](/object-types/cont.html#auto-fit) is enabled. However other widgets also use them to set spacing. See the documentation of the widgets for the details. 
 - **pad_top** (`lv_style_int_t`): Set the padding on the top.
 - **pad_bottom** (`lv_style_int_t`): Set the padding on the bottom.
 - **pad_left** (`lv_style_int_t`): Set the padding on the left.
 - **pad_right** (`lv_style_int_t`): Set the padding on the right.
 - **pad_inner** (`lv_style_int_t`): Set the padding inside the object between children.

### Background properties
The background is a simple rectangle which can have gradient and `radius` rounding.
- **bg_color** (`lv_color_t`) Specifies the color of the background. Default value: `LV_COLOR_WHITE`
- **bg_opa** (`lv_opa_t`) Specifies opacity of the background. Default value: `LV_OPA_TRANSP`.
- **bg_grad_color** (`lv_color_t`) Specifies the color of the background's gradient. The color on the right or bottom is `bg_grad_dir != LV_GRAD_DIR_NONE`. Default value: `LV_COLOR_WHITE`.
- **bg_main_stop** (`uint8_t`): Specifies where should the gradient start. 0: at left/top most position, 255: at right/bottom most position.
- **bg_grad_stop** (`uint8_t`): Specifies where should the gradient start. 0: at left/top most position, 255: at right/bottom most position. Default value: 255.
- **bg_grad_dir** (`lv_grad_dir_t`) Specifies the direction of the gradient. Can be `LV_GRAD_DIR_NONE/HOR/VER`. Default value: `LV_GRAD_DIR_NONE`. 
- **bg_blend_mode** (`lv_blend_mode_t`): Set the blend mode the background. Can be `LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE`). Default value: `LV_BLEND_MODE_NORMAL`.

```eval_rst
.. image:: /lv_examples/src/lv_ex_style/lv_ex_style_1.*
  :alt: Styling the background in lvgl

.. literalinclude:: /lv_examples/src/lv_ex_style/lv_ex_style_1.c
  :language: c
```

### Border properties
The border in drawn on to of the *background*. It has `radius` rounding.
- **border_color** (`lv_color_t`) Specifies the color of the border. 
- **border_opa** (`lv_opa_t`) Specifies opacity of the border.
- **border_width** (`lv_style_int_t`): Set the width of the border.
- **border_side** (`lv_border_side_t`) Specifies which sides of the border to draw. Can be `LV_BORDER_SIDE_NONE/LEFT/RIGHT/TOP/BOTTOM/FULL`. ORed values are also possible. Default value: `LV_BORDER_SIDE_FULL`.
- **border_post** (`bool`): If `true` the border will be drawn all children has been drawn.
- **border_blend_mode** (`lv_blend_mode_t`): Set the blend mode of the border. Can be `LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE`). Default value: `LV_BLEND_MODE_NORMAL`.

```eval_rst
.. image:: /lv_examples/src/lv_ex_style/lv_ex_style_2.*
  :alt: Styling the border in lvgl

.. literalinclude:: /lv_examples/src/lv_ex_style/lv_ex_style_2.c
  :language: c
```

### Outline properties
The outline is similar to *border* but is drawn outside of the object.
- **outline_color** (`lv_color_t`) Specifies the color of the outline.
- **outline_opa** (`lv_opa_t`) Specifies opacity of the outline.
- **outline_width** (`lv_style_int_t`): Set the width of the outline.
- **outline_pad** (`lv_style_int_t`) Set the space between the object and the outline. 
- **outline_blend_mode** (`lv_blend_mode_t`): Set the blend mode of the outline. Can be `LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE`). Default value: `LV_BLEND_MODE_NORMAL`.

```eval_rst
.. image:: /lv_examples/src/lv_ex_style/lv_ex_style_3.*
  :alt: Styling the outline in lvgl

.. literalinclude:: /lv_examples/src/lv_ex_style/lv_ex_style_3.c
  :language: c
```

### Shadow properties
The shadow is a blurred area under the object.
- **shadow_color** (`lv_color_t`) Specifies the color of the shadow.
- **shadow_opa** (`lv_opa_t`) Specifies opacity of the shadow.
- **shadow_width** (`lv_style_int_t`): Set the width (blur size) of the outline.
- **shadow_ofs_x** (`lv_style_int_t`): Set the an X offset for the shadow.
- **shadow_ofs_y** (`lv_style_int_t`): Set the an Y offset for the shadow.
- **shadow_spread** (`lv_style_int_t`): ake the shadow larger than the background in every direction by this value.
- **shadow_blend_mode** (`lv_blend_mode_t`): Set the blend mode of the shadow. Can be `LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE`). Default value: `LV_BLEND_MODE_NORMAL`.

```eval_rst
.. image:: /lv_examples/src/lv_ex_style/lv_ex_style_4.*
  :alt: Styling the shadow in lvgl

.. literalinclude:: /lv_examples/src/lv_ex_style/lv_ex_style_4.c
  :language: c
```

### Pattern properties
The pattern is an image (or symbol) drawn in the middle of the background or repeated to fill the whole background.
- **pattern_image** (`const void *`): Pointer to an `lv_img_dsc_t` variable, a path to an image file or a symbol.
- **pattern_opa** (`lv_opa_t`): Specifies opacity of the pattern.
- **pattern_recolor** (`lv_color_t`): Mix this color to the pattern image. In case of symbols (texts) it will be the text color.
- **pattern_recolor_opa** (`lv_opa_t`): Intensity of recoloring. Default value: `LV_OPA_TRANSP` (no recoloring).
- **pattern_repeat** (`bool`): `true`: the pattern will be repeated as a mosaic. `false`: place the pattern in the middle of the background.
- **pattern_blend_mode** (`lv_blend_mode_t`): Set the blend mode of the pattern. Can be `LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE`). Default value: `LV_BLEND_MODE_NORMAL`.

```eval_rst
.. image:: /lv_examples/src/lv_ex_style/lv_ex_style_5.*
  :alt: Styling the shadow in lvgl

.. literalinclude:: /lv_examples/src/lv_ex_style/lv_ex_style_5.c
  :language: c
```

### Value properties
Value is an arbitrary text drawn to the background. It can be a lightweighted replacement of the creating label objects.

- **value_str** (`const char *`): Pointer to text to display. Only the pointer is saved.
- **value_color** (`lv_color_t`): Color of the text. 
- **value_opa** (`lv_opa_t`): Opacity of the text.
- **value_font** (`const lv_font_t *`): Pointer to font of the text.
- **value_letter_space** (`lv_style_int_t`): Letter space of the text.
- **value_line_space** (`lv_style_int_t`): Line space of the text.
- **value_align** (`lv_align_t`): Alignment of the text. Can be `LV_ALIGN_...`.
- **value_ofs_x** (`lv_style_int_t`): X offset from the original position of the alignment.
- **value_ofs_y** (`lv_style_int_t`): Y offset from the original position of the alignment.
- **value_blend_mode** (`lv_blend_mode_t`): Set the blend mode of the text. Can be `LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE`). Default value: `LV_BLEND_MODE_NORMAL`.

```eval_rst
.. image:: /lv_examples/src/lv_ex_style/lv_ex_style_6.*
  :alt: Styling the value text in lvgl

.. literalinclude:: /lv_examples/src/lv_ex_style/lv_ex_style_6.c
  :language: c
```

### Text properties
Properties for textual object.
- **text_color** (`lv_color_t`): Color of the text. 
- **text_opa** (`lv_opa_t`): Opacity of the text.
- **text_font** (`const lv_font_t *`): Pointer to font of the text.
- **text_letter_space** (`lv_style_int_t`): Letter space of the text.
- **text_line_space** (`lv_style_int_t`): Line space of the text.
- **text_decor** (`lv_text_decor_t`): Add text decoration. Can be `LV_TEXT_DECOR_NONE/UNDERLINE/STRIKETHROUGH`.
- **text_sel_color** (`lv_color_t`): Set background color of text selection.
- **text_blend_mode** (`lv_blend_mode_t`): Set the blend mode of the text. Can be `LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE`). Default value: `LV_BLEND_MODE_NORMAL`.

### Line properties
Properties of lines.
- **line_color** (`lv_color_t`): Color of the line. 
- **line_opa** (`lv_opa_t`): Opacity of the line.
- **line_width** (`lv_style_int_t`): Width of the line.
- **line_dash_width** (`lv_style_int_t`): Width of dash. Dashing is drawn only for horizontal or vertical lines. 0: disable dash.
- **line_dash_gap** (`lv_style_int_t`): Gap between two dash line. Dashing is drawn only for horizontal or vertical lines. 0: disable dash.
- **line_rounded** (`bool`): `true`: draw rounded line endings.
- **line_blend_mode** (`lv_blend_mode_t`): Set the blend mode of the line. Can be `LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE`). Default value: `LV_BLEND_MODE_NORMAL`.

```eval_rst
.. image:: /lv_examples/src/lv_ex_style/lv_ex_style_7.*
  :alt: Styling aline in lvgl

.. literalinclude:: /lv_examples/src/lv_ex_style/lv_ex_style_7.c
  :language: c
```

### Image properties
Properties of image.
- **image_recolor** (`lv_color_t`):  Mix this color to the pattern image. In case of symbols (texts) it will be the text color.
- **image_recolor_opa** (`lv_opa_t`): Intensity of recoloring. Default value: `LV_OPA_TRANSP` (no recoloring).
- **image_opa** (`lv_opa_t`): Opacity of the image.
- **image_blend_mode** (`lv_blend_mode_t`): Set the blend mode of the image. Can be `LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE`). Default value: `LV_BLEND_MODE_NORMAL`.

```eval_rst
.. image:: /lv_examples/src/lv_ex_style/lv_ex_style_8.*
  :alt: Styling an image in lvgl

.. literalinclude:: /lv_examples/src/lv_ex_style/lv_ex_style_8.c
  :language: c
```

### Transition properties
Properties to describe state change animations.
- **transition_time** (`lv_style_int_t`): Time of the transition.
- **transition_delay** (`lv_style_int_t`): Delay before the transition.
- **transition_1** (`property name`): A property on which transition should be applied. Use the property name with upper case with `LV_STYLE_` prefix, e.g. `LV_STYLE_BG_COLOR`
- **transition_2** (`property name`): Same as *transition_1* just for an other property.
- **transition_3** (`property name`): Same as *transition_1* just for an other property.
- **transition_4** (`property name`): Same as *transition_1* just for an other property.
- **transition_5** (`property name`): Same as *transition_1* just for an other property.
- **transition_6** (`property name`): Same as *transition_1* just for an other property.
- **transition_path** (`lv_anim_path_cb_t`): An animation path for the transition. Built pats can be used, e.g. `lv_anim_path_overshoot`.

```eval_rst
.. image:: /lv_examples/src/lv_ex_style/lv_ex_style_9.*
  :alt: Styling an transitions in lvgl

.. literalinclude:: /lv_examples/src/lv_ex_style/lv_ex_style_9.c
  :language: c
```

### Scale properties
Auxiliary properties for scale like elements. Scales have a normal and and end region. 
As the name implies the end region is the end of the scale where can be critical values or inactive values. The normal region is before the end region. 
Both region could have different properties.
- **scale_grad_color** (`lv_color_t`):  In normal region make gradient to this color on the scale lines. 
- **scale_end_color** (`lv_color_t`):  Color of the scale lines in the end region. 
- **scale_width** (`lv_style_int_t`): Width of the scale. Default value: `LV_DPI / 8`.
- **scale_border_width** (`lv_style_int_t`): Width of a border drawn on the outer side of the scale in the normal region.
- **scale_end_border_width** (`lv_style_int_t`): Width of a border drawn on the outer side of the scale in the end region.
- **scale_end_line_width** (`lv_style_int_t`): Width of a scale lines in the end region.



A style is a structure with attributes like colors, paddings, opacity, font, etc.

There is a common style type called **lv_style_t** for every object type.

By setting the fields of the `lv_style_t` variables and assigning them to objects with `lv_obj_set_style`, you can influence the appearance of the objects.

``` important:: The objects only store a pointer to a style so the style cannot be a local variable which is destroyed after the function exits. **You should use static, global or dynamically allocated variables.**
```

```c
/* file scope */
lv_style_t style_1;             /*OK! Global variables for styles are fine*/
static lv_style_t style_2;      /*OK! Static variables outside the functions are fine*/
void my_screen_create(void)
{
  /* function scope */
  static lv_style_t style_3;    /*OK! Static variables in the functions are fine*/
  lv_style_t style_4;           /*WRONG! Styles can't be local variables*/

  ...
}
```

## Use the styles

Objects have a *main style* which determines the appearance of their background or main section. However, some object types have additional styles too.

For example, a slider has 3 styles:
- Background (main style)
- Indicator
- Know

Some object types only have one style. For example:
- Label
- Image
- Line, etc.

Every object type implements its own version of the style setter and getter functions. You should use these instead of `lv_obj_set_style` where possible. For example:
```c
const lv_style_t * btn_style = lv_btn_get_style(btn, LV_BTN_STYLE_REL);
lv_btn_set_style(btn, LV_BTN_STYLE_REL, &new_style);
```

To see the styles supported by an object type  (*LV_<OBJ_TYPE>_STYLE_<STYLE_TYPE>*), check the documentation of the particular [Object type](/object-types/index).

If you **modify a style which is already used** by one or more objects, then the objects have to be notified about the style is changed. There are two options to do this notification:

```c
/*Notify an object about its style is modified*/
void lv_obj_refresh_style(lv_obj_t * obj);

/*Notify all objects with a given style. (NULL to notify all objects)*/
void lv_obj_report_style_mod(void * style);
```

`lv_obj_report_style_mod` will only refresh the *Main styles* of objects. If you change a different style, you will have to use `lv_obj_refresh_style`. 

## Inherit styles

If the *Main style* of an object is `NULL`, then its style will be inherited from its parent's style. It makes easier to create a consistent design. Don't forget a style describes a lot of properties at the same time. So for example, if you set a button's style and create a label on it with `NULL` style, then the label will be rendered according to the button's style. In other words, the button makes sure its children will look good on it.

Setting the `glass` style property will prevent inheriting that style (i.e. cause the child object to inherit its style from its grandparent). You should use it if the style is transparent so children use colors and features from its grandparent. Otherwise, the child objects would also be transparent.

## Style properties
A style has 5 main parts: common, body, text, image and line. Each object type only uses the fields which are relevant to it.
For example, *Lines* don't care about the *letter_space*, because they are not concerned with rendering text.

To see which fields are used by an object type, see their [Documentation](/object-types/index).

The fields of a style structure are the followings:

#### Common properties
  * **glass** 1: Do not inherit this style

#### Body style properties
Used by the rectangle-like objects
  - **body.main_color** Main color (top color)
  - **body.grad_color** Gradient color (bottom color)
  - **body.radius** Corner radius. (set to `LV_RADIUS_CIRCLE` to draw circle)
  - **body.opa** Opacity (0..255 or *LV_OPA_TRANSP*, *LV_OPA_10*, *LV_OPA_20* ... *LV_OPA_COVER*)
  - **body.border.color** Border color
  - **body.border.width** Border width
  - **body.border.part** Border parts (*LV_BORDER_LEFT/RIGHT/TOP/BOTTOM/FULL* or 'OR'ed values)
  - **body.border.opa** Border opacity (0..255 or *LV_OPA_TRANSP*, *LV_OPA_10*, *LV_OPA_20* ... *LV_OPA_COVER*)
  - **body.shadow.color** Shadow color
  - **body.shadow.width** Shadow width
  - **body.shadow.type** Shadow type (*LV_SHADOW_BOTTOM/FULL*)
  - **body.padding.top** Top padding
  - **body.padding.bottom** Bottom padding
  - **body.padding.left** Left padding
  - **body.padding.right** Right padding
  - **body.padding.inner** Inner padding (between content elements or children)

#### Text style properties
Used by the objects which show texts
  - **text.color** Text color
  - **text.sel_color** Selected text color
  - **text.font** Pointer to a font
  - **text.opa** Text opacity (0..255 or LV_OPA_TRANSP, LV_OPA_10, LV_OPA_20 ... LV_OPA_COVER*)
  - **text.letter_space** Letter space
  - **text.line_space** Line space

#### Image style properties
Used by image-like objects or icons on objects
  - **image.color** Color for image re-coloring based on the brightness of its pixels
  - **image.intense** Re-color intensity (0..255 or *LV_OPA_TRANSP*, *LV_OPA_10*, *LV_OPA_20* ... *LV_OPA_COVER*)
  - **image.opa** Overall image opacity (0..255 or *LV_OPA_TRANSP*, *LV_OPA_10*, *LV_OPA_20* ... *LV_OPA_COVER*)

#### Line style properties
Used by objects containing lines or line-like elements
  - **line.color** Line color
  - **line.width** Line width
  - **line.opa** Line opacity (0..255 or *LV_OPA_TRANSP*, *LV_OPA_10*, *LV_OPA_20* ... *LV_OPA_COVER*)

## Built-in styles
There are several built-in styles in the library:

![](/misc/style-built-in.png "Built-in styles in LittlevGL Embedded Graphics Library")

As you can see, there are built-in styles for screens, buttons, solid containers, and transparent containers.

The `lv_style_transp`, `lv_style_transp_fit` and `lv_style_transp_tight` differ only in paddings: for `lv_style_transp_tight` all paddings are zero, for `lv_style_transp_fit` only horizontal and vertical paddings are zero but has inner padding.

``` important:: Transparent built-in styles have *glass = 1* by default which means these styles (e.g. their colors) won't be inherited by children.
```

The built in styles are global `lv_style_t` variables. You can use them like:
```c
lv_btn_set_style(obj, LV_BTN_STYLE_REL, &lv_style_btn_rel)
```

## Create new styles
You can either modify the built-in styles or can create new styles.

When creating new styles, it's recommended to first copy a built-in style with `lv_style_copy(&dest_style, &src_style)` to be sure all fields are initialized with the proper value.

Do not forget to initialize the new style as `static` or `global`. For example:
```c
static lv_style_t my_red_style;
lv_style_copy(&my_red_style, &lv_style_plain);
my_red_style.body.main_color = LV_COLOR_RED;
my_red_style.body.grad_color = LV_COLOR_RED;
```


## Style animations
You can change the styles with animations using `lv_style_anim_...()` function. The `lv_style_anim_set_styles()` uses 3 styles. Two styles are required to represent the *start* and *end* state, and a third style required for the *animation*.

Here is an example to show how it works.

```c
lv_anim_t a;
lv_style_anim_init(&a);                                                 /*A basic initialization*/
lv_style_anim_set_styles(&a, &style_to_anim, &style_start, &style_end); /*Set the styles to use*/
lv_style_anim_set_time(&a, duration, delay);                           /*Set the duration and delay*/
lv_style_anim_create(&a);                                               /*Create the animation*/
```

Essentially, `style_start` and `style_end` remain unchanged, and `style_to_anim` is interpolated over the course of the animation.
 
See `lv_core/lv_style.h` to know the whole API of style animations.

Check [Animations](/overview/animation) for more information.

## Style example
The example below demonstrates the usage of styles.

![](/misc/style-example.png "Styles usage example in LittlevGL Embedded Graphics Library")
```c
/*Create a style*/
static lv_style_t style1;
lv_style_copy(&style1, &lv_style_plain);    /*Copy a built-in style to initialize the new style*/
style1.body.main_color = LV_COLOR_WHITE;
style1.body.grad_color = LV_COLOR_BLUE;
style1.body.radius = 10;
style1.body.border.color = LV_COLOR_GRAY;
style1.body.border.width = 2;
style1.body.border.opa = LV_OPA_50;
style1.body.padding.left = 5;            /*Horizontal padding, used by the bar indicator below*/
style1.body.padding.right = 5;
style1.body.padding.top = 5;            /*Vertical padding, used by the bar indicator below*/
style1.body.padding.bottom = 5;
style1.text.color = LV_COLOR_RED;

/*Create a simple object*/
lv_obj_t *obj1 = lv_obj_create(lv_scr_act(), NULL);
lv_obj_set_style(obj1, &style1);                        /*Apply the created style*/
lv_obj_set_pos(obj1, 20, 20);                           /*Set the position*/

/*Create a label on the object. The label's style is NULL by default*/
lv_obj_t *label = lv_label_create(obj1, NULL);
lv_obj_align(label, NULL, LV_ALIGN_CENTER, 0, 0);       /*Align the label to the middle*/

/*Create a bar*/
lv_obj_t *bar1 = lv_bar_create(lv_scr_act(), NULL);
lv_bar_set_style(bar1, LV_BAR_STYLE_INDIC, &style1);    /*Modify the indicator's style*/
lv_bar_set_value(bar1, 70);                             /*Set the bar's value*/
```

## Themes
Creating styles for the GUI is challenging because you need a deeper understanding of the library, and you need to have some design skills. Also, it takes a lot of time to create so many styles for many different objects.

Themes are introduced to speed up the design part. A theme is a style collection which contains the required styles for every object type. For example, 5 styles for a button to describe its 5 possible states.
Check the [Existing themes](https://littlevgl.com/themes) or try some in the [Live demo](https://littlevgl.com/live-demo) section. The [theme selector demo](https://littlevgl.com/demo-theme-selector) is useful to see how a given theme and color hue looks on the display.

To be more specific, a theme is a structure variable that contains a lot of `lv_style_t *` fields. For buttons:
```c
theme.btn.rel       /*Released button style*/
theme.btn.pr        /*Pressed button style*/
theme.btn.tgl_rel   /*Toggled released button style*/
theme.btn.tgl_pr    /*Toggled pressed button style*/
theme.btn.ina       /*Inactive button style*/
```

A theme can initialized by: `lv_theme_<name>_init(hue, font)`. Where `hue` is a Hue value from [HSV color space](https://en.wikipedia.org/wiki/Hue) (0..360) and `font` is the font applied in the theme (`NULL` to use the `LV_FONT_DEFAULT`)

When a theme is initialized its styles can be used like this:

![](/misc/theme-example.png "Theme usage example in Littlev Embedded Graphics Library")

```c
/*Create a default slider*/
lv_obj_t *slider = lv_slider_create(lv_scr_act(), NULL);
lv_slider_set_value(slider, 70);
lv_obj_set_pos(slider, 10, 10);

/*Initialize the alien theme with a reddish hue*/
lv_theme_t *th = lv_theme_alien_init(10, NULL);

/*Create a new slider and apply the themes styles*/
slider = lv_slider_create(lv_scr_act(), NULL);
lv_slider_set_value(slider, 70);
lv_obj_set_pos(slider, 10, 50);
lv_slider_set_style(slider, LV_SLIDER_STYLE_BG, th->slider.bg);
lv_slider_set_style(slider, LV_SLIDER_STYLE_INDIC, th->slider.indic);
lv_slider_set_style(slider, LV_SLIDER_STYLE_KNOB, th->slider.knob);
```

You can ask the library to automatically apply the styles from a theme when you create new objects. To do this use `lv_theme_set_current(th)`.

```c
/*Initialize the alien theme with a reddish hue*/
lv_theme_t *th = lv_theme_alien_init(10, NULL);
lv_theme_set_current(th);

/*Create a slider. It will use the style from teh current theme.*/
slider = lv_slider_create(lv_scr_act(), NULL);
```

Themes can be enabled or disabled one by one in `lv_conf.h`.

### Live update
By default, if `lv_theme_set_current(th)` is called again, it won't refresh the styles of the existing objects. To enable live update of themes, enable `LV_THEME_LIVE_UPDATE` in `lv_conf.h`.

Live update will only update objects using the unchanged theme styles, i.e. objects created after the first call of `lv_theme_set_current(th)` or to which the theme's styles were applied manually.
